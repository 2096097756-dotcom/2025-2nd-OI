#include<stdio.h>
int main(){
    /*
    This file is intentionally left blank.
    It serves as a placeholder for the Pointer Homework on 2025-12-01.
    Please implement your pointer-related tasks here.
    */
   /*
   第二题：下列选项错误的是（）
   &a=pa;a的地址不可改变



   3.已定义：int a=2, *p1, *p2; 若 p1 和 p2 都已指向变量 k，下面选项中不能正确运行的语句是（）。
A. k=*p1+*p2;
B. p2=k;
C. p1=p2;
D. k=*p1**p2;
A. k = *p1 + *p2; （正确）
类型分析：
*p1 是 int 类型（k的值）。
*p2 是 int 类型（k的值）。
等式右边是两个整数相加，结果是 int。
等式左边 k 是 int 变量。
含义：相当于执行 k = k + k;。
结论：语法完全正确，可以运行。
B. p2 = k; （错误）
类型分析：
等式左边 p2 是 int * 类型（指针/地址）。
等式右边 k 是 int 类型（整数数值）。
错误原因：
类型不匹配：C语言中，不能直接将一个整数赋值给一个指针变量（除非强制类型转换，或者该整数是常数 0/NULL）。编译器通常会报错（cannot convert 'int' to 'int*'）或报警告。
危险操作：即使强制赋值，将一个普通整数（比如 2）当作地址赋给指针，意味着 p2 指向了内存地址为 2 的地方。这通常是系统保留区，如果后续试图访问 *p2，程序会立即崩溃（Segmentation Fault）。
结论：不能正确运行。
C. p1 = p2; （正确）
类型分析：
左边 p1 是 int *。
右边 p2 是 int *。
含义：这是指针赋值。将 p2 存储的地址复制给 p1。执行后，p1 和 p2 指向同一个地方。题目中说它们本来就都指向 k，这个操作虽然多余，但在语法和逻辑上都是合法的。
结论：语法正确，可以运行。
D. k = *p1 * *p2; （正确）
类型分析：
第一个 * 是解引用运算符，*p1 取出 k 的值。
第二个 * 是乘法运算符。
第三个 * 是解引用运算符，*p2 取出 k 的值。
含义：相当于执行 k = k * k;（求平方）。
结论：语法正确，可以运行。





   */
  /*
    int a=10,k=20;
    int *p=&a;
    printf("%d %d",p,&a);
    p=k;//这里有问题！左边是int*类型（指针或者地址类型）
    printf("%d",p);
*/

/*
4. (单选题) 以下对二维数组a进行正确初始化的是_( )____.
A
int a[2][3]={ {1,2},{3,4},{5,6} };

B
int a[ ][3]={1,2,3,4,5,6 };

C
int a[2][ ]={1,2,3,4,5,6};

D
int a[2][ ]={ { 1,2},{3,4;

A. int a[2][3]={ {1,2},{3,4},{5,6} }; （错误）
定义的容量：a[2][3] 表示这个数组只有 2 行，每行 3 列。
提供的数据：花括号 {} 分组表示行。
第一组 {1,2} 对应第 0 行；
第二组 {3,4} 对应第 1 行；
第三组 {5,6} —— 越界了！
错误原因：初始化列表中提供了 3 行数据，但数组声明时只给出了 2 行的存储空间。初始化的元素个数超过了数组的定义范围。

B. int a[ ][3]={1,2,3,4,5,6 }; （正确）
定义的容量：a[ ][3]。
列数固定为 3。
行数为空，表示让编译器自动计算。
提供的数据：一共有 6 个整数 {1,2,3,4,5,6}。
编译器计算过程：
数据总数 = 6。
每行长度 = 3。
自动计算行数 = 
6
÷
3
=
2
6÷3=2
 行。
所以，这等价于声明 int a[2][3]。
结论：符合语法规则，能够正确推断出数组的大小。

C. int a[2][ ]={1,2,3,4,5,6}; （错误）
定义的容量：a[2][ ]。
行数为 2。
列数为空。
错误原因：列宽不能省略。
如果没有列宽，编译器面对这 6 个数据，不知道该怎么切分。
是分成 2 行，每行 3 个？
还是分成 2 行，每行 30 个（后面补零）？
由于这种不确定性，C 语言禁止省略第二维（列）的大小。

D. int a[2][ ]={ { 1,2},{3,4; （错误）
错误原因 1：同选项 C，省略了列宽 [ ]，这是语法错误。
错误原因 2：书写格式也有明显错误（缺少结尾的 }），不过最根本的逻辑错误依然是省略了列数。

行宽可以省略，列宽不能省略（每行有几个不能省略）



5.定义二维数组：float data[][3]={{1,2,3},{4,5,6}};

如果以此二维数组做为函数的实参，调用方式为：matrix(data,2,3);

那么下面选项的函数声明正确的是（）。

答案：C
解析： 二维数组作为函数参数时，实参 data（类型 float(*)[3]）传递给形参，形参必须匹配该类型。
A：float data[][] 语法错误，必须指定列宽。
B：float (*p)[4] 列宽为4，与实参的3不匹配。
D：类型是 int，与实参 float 不匹配。
C：float data[][3] 等价于 float (*data)[3]，完全匹配。



6.6. (多选题) 下列指针变量的定义及初始化正确的是（）。
A
int *p,a=10;p=&a;

B
void *v=NULL;

C
char *p="Hello";

D
double d=1.0,*pd=&d;

都是合法的，直接指向了某个地址，写在一行里没有有问题
*p="Hello"==char ch[]="Hello"


9. (多选题) 请问下面的选项，错误的有（）。
A
    int year=2025,*p;//这里p没有指定地址

    *p=1958;

B
    int year=2025,*p；

    *p=&year;//不能转换*int 与 int

C
    int year=2025,*p=&year;//可以

    *p=1958;



D
    int year=2025,*p=NULL,*q=p;//可以

E
    int year=2025,*p=NULL,*q=p;

    *q=year;






 10.   若有如下语句：
char str[10]="Hello", *pstr="USTC";
请问下列选项中正确的有（）。
A. pstr=str;
B. pstr=&str[0];
C. str=pstr;
D. str="USTC";
E. pstr="Hello";
F. str[0]='h';
G. pstr=str; *pstr='h';
H. *pstr="Hello";
I. pstr="USTC",*p='u';
J. pstr=str; if(pstr+3==str+3){}
正确答案：A、B、E、F、G、J
核心考点解析
这道题主要考察 字符数组（Array） 与 字符指针（Pointer） 的本质区别：
str（数组名）：
内存：在栈上分配了10个字节的空间，内容可读可写。
性质：str 本身是一个地址常量（Constant Address）。你可以修改它里面存放的内容（如 str[0]='h'），但不能修改 str 这个标签所代表的地址（即不能对 str 进行赋值操作，如 str = ... 是非法的）。
pstr（指针变量）：
内存：本身只是一个存储地址的变量（4或8字节）。
指向：初始化时指向了 "USTC"。这是一个字符串常量，通常存储在常量区（只读区），不能通过 *pstr = ... 去修改内容。
性质：pstr 是变量，可以随时改变它指向的地址（即可以对 pstr 进行赋值操作）。
逐个选项深度解析
A. pstr=str; （正确）
分析：pstr 是指针变量，可以改变指向。str 是数组首地址。
含义：让指针 pstr 放弃指向常量区的 "USTC"，转而指向栈上的数组 str。
结果：合法。此时 pstr 也指向了 "Hello"。
B. pstr=&str[0]; （正确）
分析：&str[0] 就是数组第一个元素的地址，本质上等同于 str。
结果：与 A 选项完全一样，合法。
C. str=pstr; （错误）
分析：str 是数组名，视为地址常量。
比喻：你的家庭住址（门牌号）是固定的，不能说把“别人的地址”赋值给“你的门牌号”。
结果：编译错误，数组名不可作为左值被赋值。
D. str="USTC"; （错误）
分析：同上。"USTC" 是一个字符串常量的地址，试图把它赋值给数组名 str。
注意：如果是初始化 char str[] = "USTC"; 是对的，但作为赋值语句 str = ... 是错的。
结果：编译错误。
E. pstr="Hello"; （正确）
分析：pstr 是变量。
含义：让 pstr 指向内存中另一个字符串常量 "Hello" 的地址。
结果：合法。
F. str[0]='h'; （正确）
分析：str 数组所在的内存是可读写的（栈区）。
含义：把第一个字符 'H' 修改为 'h'。
结果：合法。
G. pstr=str; *pstr='h'; （正确）
分析：
pstr=str;：先让 pstr 指向数组 str（可写区域）。
*pstr='h';：通过指针修改该区域的第一个字符。
结果：合法。因为 pstr 现在指向的是栈上的数组，而不是只读常量区。
H. *pstr="Hello"; （错误）//*pstr是字符类型，指向第一个patr[0]
分析：
类型不匹配：*pstr 是 char 类型（一个字符），而 "Hello" 是 char * 类型（一个地址）。不能把一个地址赋值给一个字符。
逻辑错误：即使类型匹配，pstr 初始指向只读常量区 "USTC"，试图写入也会导致运行时崩溃。
I. pstr="USTC", *p='u'; （错误）
分析：这里假设是在定义变量或逗号表达式。
如果看作定义：char *p='u'; 试图用字符 'u'（ASCII码 117）作为一个内存地址来初始化指针 p。这是非常危险且类型错误的（int 转 int*）。//p:*int类型
如果看作赋值：这里并没有定义 p 变量，使用未定义的变量是错误的。
J. pstr=str; if(pstr+3==str+3){} （正确）
分析：
pstr=str; 执行后，pstr 和 str 存储的地址值完全相同。
所以 pstr+3 和 str+3 计算出的地址自然也相同。
结果：逻辑正确，语法合法。
总结
数组名 str：是地基，不能动（不能赋值），但房子里装修（内容）可以改。
指针 pstr：是手指，可以乱指（可以赋值指向别处），但指到“只读保护区”时不能去乱改内容。




若有如下语句：
double data[3][4], (*p)[4]=data;
请问下面选项与 data[2][3] 等价的有（）。
A. p[2][3]
B. (*(data+2))[3]
C. *(data[2]+3)
D. *(*(data+2)+3)
E. *(p[2]+3)
F. *(*(p+2)+3)
G. (*(p+2))[3]
H. *(data+2)[3]
正确答案：A、B、C、D、E、F、G
核心知识点：二维数组与行指针
要解决这道题，必须彻底理解 data 和 p 的身份，以及 [] 与 * 的转换关系。
变量身份：
data：二维数组名。在表达式中，它代表第0行的行地址。类型是 double (*)[4]（指向含有4个double元素的数组的指针）。
p：行指针变量。定义为 double (*p)[4] 并初始化为 data。这意味着 p 和 data 是完全等价的，可以互换使用。
公式转换（黄金法则）：
在C语言中，x[i] 永远等价于 *(x + i)。
对于二维数组 data[i][j]，它的标准指针形式是：
∗
(
∗
(
d
a
t
a
+
i
)
+
j
)
∗(∗(data+i)+j)
第一步（找行）：data + i 是第 i 行的地址。
第二步（进列）：*(data + i) 解引用后变成了第 i 行的首元素地址（即 data[i]）。
第三步（移位）：+ j 向后移动 j 个元素。
第四步（取值）：最外层的 * 取出最终数值。
逐个选项深度拆解
我们的目标是访问 第2行，第3列 的元素。
A. p[2][3] （正确）
解析：因为 p 指向 data，且类型完全一致，所以 p 可以像数组名一样使用下标。
等价：p[2][3] == data[2][3]。
B. (*(data+2))[3] （正确）
解析：
data+2：指向第2行。
*(data+2)：解引用，变成了第2行的行名（等价于 data[2]）。
(...)[3]：对行名取下标，即取第2行的第3个元素。
等价：data[2][3]。
C. *(data[2]+3) （正确）
解析：
data[2]：第2行的首地址（指向元素的指针）。
+3：向后移动3个元素的位置。
*：取出那个位置的值。
等价：data[2][3]。
D. *(*(data+2)+3) （正确）
解析：这是二维数组取值的标准教科书写法（纯指针形式）。
*(data+2) 拿到行首地址。
+3 偏移列。
* 取值。
等价：data[2][3]。
E. *(p[2]+3) （正确）
解析：同选项 C。只是把 data 换成了 p。
p[2] 等价于 *(p+2)，即第2行首地址。
再 +3 取值，完全正确。
F. *(*(p+2)+3) （正确）
解析：同选项 D。这是 p[2][3] 的纯指针写法。
G. (*(p+2))[3] （正确）
解析：同选项 B。*(p+2) 还原为行名（p[2]），再用下标访问。
为什么 H 选项是错误的？（陷阱分析）
H. *(data+2)[3] （错误）
这里涉及 C 语言运算符的优先级问题：
[]（下标）的优先级 高于 *（解引用）。
+（加法）的优先级 低于 []。
我们来模拟编译器的解析过程：
分组：由于 [] 优先级高，编译器会先结合 (data+2) 和 [3]。
表达式被解析为：*( (data+2)[3] )
计算下标 (data+2)[3]：
记住公式 A[i] 等价于 *(A+i)。
所以 (data+2)[3] 等价于 * ( (data+2) + 3 )。
即：*(data + 5)。
含义：这是指向 第5行 的行指针。
最后的解引用 *：
最外层的 * 对“第5行行指针”进行解引用，得到的是“第5行首元素的地址”。
结果：
它最终指向的是 data[5][0] 的地址。
错误点：
我们要找的是 data[2][3]，不是 data[5][0]。
原数组只有 3 行（0,1,2），访问第 5 行属于严重越界。
如何修正 H？
必须加上括号来改变优先级，变成选项 B 的样子： (*(data+2))[3]。
p[3][5]->(*p)[5],A[5]=*(A+5)







第12题详细解析
题目回顾：
若有如下语句：
float score[10], data[2][3];
float *ps, (*pd)[3];
请问下面哪些选项是正确的（）。
A. ps=score;
B. ps=&score[0];
C. ps=&data[0][0];
D. ps=data[0];
E. ps=*data;
F. pd=&data[0];
G. pd=data;
正确答案：A、B、C、D、E、F、G （全选）
核心知识点：类型匹配
做这类指针赋值题，最关键的只有一步：看等号两边的“类型”是否一致。
首先，我们要把定义好的变量类型“翻译”清楚：
ps：定义为 float *ps。
这是一个普通指针。
它专门用来存放单个 float 变量的地址。
它的类型是：float *。
pd：定义为 float (*pd)[3]。
这是一个数组指针（行指针）。
它专门用来存放**“长度为3的 float 数组”的地址**。
它的类型是：float (*)[3]。
score：一维数组 float score[10]。
数组名在表达式中退化为首元素地址。
类型是：float *。
data：二维数组 float data[2][3]。
数组名在表达式中退化为第0行的行地址。
类型是：float (*)[3]。
逐个选项深度解析
第一组：赋值给 ps (要求右边必须是 float *)
A. ps = score; （正确）
score 是数组名，退化为首元素 &score[0] 的地址。
类型：float *。
匹配：float * = float *。
B. ps = &score[0]; （正确）
score[0] 是一个 float 变量，& 取它的地址。
类型：float *。
匹配：float * = float *。
C. ps = &data[0][0]; （正确）
data[0][0] 是二维数组里的一个具体元素（float）。
取它的地址自然就是 float *。
匹配：float * = float *。
D. ps = data[0]; （正确）
关键点：data[0] 是二维数组第0行的行名。
行名相当于一个一维数组的数组名。
一维数组名退化为首元素地址，即 &data[0][0]。
类型：float *。
匹配：float * = float *。
E. ps = *data; （正确）
关键点：*data 等价于 *(data + 0) 等价于 data[0]。
解释：data 是行指针，* 解引用后，就进入了这一行，变成了“行名”。
如选项D所述，行名就是首元素地址。
类型：float *。
匹配：float * = float *。
第二组：赋值给 pd (要求右边必须是 float (*)[3])
F. pd = &data[0]; （正确）
关键点：data[0] 代表第0行（本质是一个数组）。
&data[0] 是对这个数组取地址。
注意：对数组名取地址（&数组名），得到的不是元素指针，而是整个数组的指针。
类型：float (*)[3]。
匹配：float (*)[3] = float (*)[3]。
G. pd = data; （正确）
data 是二维数组名。
二维数组名退化为“首行的地址”。
首行是一个包含3个浮点数的数组。
类型：float (*)[3]。
匹配：float (*)[3] = float (*)[3]。
总结与对比（避坑指南）
请务必区分以下三个概念的细微差别，这是考试中最容易混淆的地方：
data：
含义：第0行的地址（行级）。
类型：float (*)[3]。
能赋值给 pd。
data[0]：
含义：第0行第0个元素的地址（元素级）。
类型：float *。
能赋值给 ps。
&data[0]：
含义：取“第0行”这个数组对象的地址。
类型：float (*)[3]。
能赋值给 pd。
本题的所有选项都巧妙地符合了上述规则，因此全对。
这种题判断变量类型就可以了




14.题目代码回顾：
code
C
#include <stdio.h>
 
int main(void)
{
    int a[]={0,1,2,3,4,5,6,7,8,9};
    int *p=a, *q=&a[9];
 
    printf("%d\n", *p++);  // 第1行输出
    printf("%d\n", *++p);  // 第2行输出
    printf("%d\n", *q--);  // 第3行输出
    printf("%d\n", *--q);  // 第4行输出
 
    while(p<=q)
    {
        printf("%d %d\n", *p++, *q--); // 循环输出
    }
 
    return 0;
}
核心考点
后置自增/自减 (*p++, *q--)：先取值，再移动指针。
前置自增/自减 (*++p, *--q)：先移动指针，再取值。
指针比较 (p <= q)：判断两个指针的位置关系。
详细执行步骤分析
1. 初始化状态
数组 a：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
指针 p：指向 a[0] (值为 0)。
指针 q：指向 a[9] (值为 9)。
2. 单步执行分析
语句 1：printf("%d\n", *p++);
动作：这是后置自增。
先取出 p 指向的值：0 (即 a[0])。
然后 p 向后移一位，指向 a[1]。
输出：0
当前状态：p 指向 a[1] (值1)。
语句 2：printf("%d\n", *++p);
动作：这是前置自增。
先将 p 向后移一位，从 a[1] 移到 a[2]。
再取出 p 指向的新值：2 (即 a[2])。
输出：2
当前状态：p 指向 a[2] (值2)。
语句 3：printf("%d\n", *q--);
动作：这是后置自减。
先取出 q 指向的值：9 (即 a[9])。
然后 q 向前移一位，指向 a[8]。
输出：9
当前状态：q 指向 a[8] (值8)。
语句 4：printf("%d\n", *--q);
动作：这是前置自减。
先将 q 向前移一位，从 a[8] 移到 a[7]。
再取出 q 指向的新值：7 (即 a[7])。
输出：7
当前状态：q 指向 a[7] (值7)。
3. 循环部分分析 (while(p <= q))
进入循环前的状态：
p 指向 a[2] (值2)
q 指向 a[7] (值7)
判断：p <= q 成立（地址 &a[2] 小于 &a[7]），进入循环。
第一轮循环：
语句：printf("%d %d\n", *p++, *q--);
动作：
输出 *p (当前是 2)，然后 p 移向 a[3]。
输出 *q (当前是 7)，然后 q 移向 a[6]。
输出：2 7
状态更新：p->a[3]，q->a[6]。
第二轮循环：
判断：p (a[3]) <= q (a[6]) 成立。
动作：
输出 *p (3)，然后 p 移向 a[4]。
输出 *q (6)，然后 q 移向 a[5]。
输出：3 6
状态更新：p->a[4]，q->a[5]。
第三轮循环：
判断：p (a[4]) <= q (a[5]) 成立。
动作：
输出 *p (4)，然后 p 移向 a[5]。
输出 *q (5)，然后 q 移向 a[4]。
输出：4 5
状态更新：p->a[5]，q->a[4]。
第四轮循环判断：
判断：p 指向 a[5]，q 指向 a[4]。
此时地址 p > q，条件 p <= q 不成立。
退出循环。
最终输出结果整理
code
Text
0
2
9
7
2 7
3 6
4 5



15.若有如下语句：

double gpa[10],*p=gpa;

那么，sizeof(gpa)=_________，sizeof(p)=_______，sizeof(gpa[0])=___________。
答案：
第1空：80 (10 * 8 bytes)
第2空：4 (或 8) (取决于系统位数，32位为4，64位为8，通常考试默认4或都算对)
第3空：8 (double 类型大小)



您所询问的“填空题第四题”对应试卷中的 第16题。
题目回顾：
若有如下语句：
char str[]="Hello", greetings[10]="Ustcer", *p="welcome";
那么：
sizeof(str)=________;
sizeof(greetings)=__________;
sizeof(p)=________;
strlen(str)=________;
strlen(greetings)=__________;
strlen(p)=________;
sizeof("Hello")=_________;
strlen("Hello")=________;
核心考点：sizeof 与 strlen 的区别
这是 C 语言考试中最经典的考点之一，必须牢记以下区别：
特性	sizeof(...)	strlen(...)
本质	运算符 (Operator)	函数 (Function)
计算时机	编译时计算 (Compile-time)	运行时计算 (Run-time)
计算内容	变量或类型占用的内存总空间	字符串中有效字符的个数
包含 \0?	包含 (如果是数组初始化)	不包含 (遇到 \0 就停止)
逐空详细解析
1. sizeof(str)
定义：char str[] = "Hello";
分析：这是一个字符数组。编译器会根据初始化字符串的长度自动计算大小。
内存内容：'H', 'e', 'l', 'l', 'o', '\0' (共6个字符)。
计算：5个可见字符 + 1个结束符 = 6字节。
结果：6
2. sizeof(greetings)
定义：char greetings[10] = "Ustcer";
分析：定义时明确指定了大小为 [10]。
原理：无论你里面存了几个字，这块地皮既然圈了10平米，sizeof 测出来的就是 10平米。
结果：10
3. sizeof(p)
定义：char *p = "welcome";
分析：p 是一个指针变量。
原理：sizeof 测的是 p 这个变量本身（也就是那个存放地址的盒子）的大小，而不是它指向的字符串的大小。
在 32 位系统中，指针占 4 字节。
在 64 位系统中，指针占 8 字节。
注：考试通常默认 32 位环境，填 4；如果环境不确定，填 4 或 8 均算理解正确。
结果：4 (或 8)
4. strlen(str)
分析：数一数 str 里有多少个字符，直到遇到 \0。
内容：Hello
结果：5
5. strlen(greetings)
分析：虽然数组大小是10，但里面存放的字符串是 "Ustcer"。
计算：U-s-t-c-e-r，共6个字符。
结果：6
6. strlen(p)
分析：p 指向 "welcome"。
计算：w-e-l-c-o-m-e，共7个字符。
结果：7
7. sizeof("Hello")
分析："Hello" 是一个字符串字面量。
类型：它的类型是 char[6]（隐含结尾的 \0）。
计算：5个字母 + 1个 \0。
结果：6
8. strlen("Hello")
分析：直接数有效字符个数。
结果：5
总结答案
6
10
4 (或 8)
5
6
7
6
5





指针数组：int *p[4]//本质是数组，里面全是指针
结合顺序：p 先与 [4] 结合。
结论：所以 p 首先是一个数组。
修饰：剩下的 int * 是用来修饰数组元素的。
理解：这是一个有着4个格子的数组，每个格子里装的是 int *（整型指针）。

数组指针：int (*p)[4]//本质是指针，指向一个数组
结合顺序：因为有了括号 ()，p 强制先与 * 结合。
结论：所以 p 首先是一个指针。
修饰：剩下的 int [4] 描述了这个指针指向的目标类型。
理解：这是一个指针，它专门用来指向一个“长度为4的整型数组”。

p[4]->数组
*p[4]->数组里装的全是指针


*f()//函数，返回类型是指针。指针函数
(*f)()//指针指向一个函数。函数指针







int *f() —— 指针函数
分析：()（函数括号，No.2）优先级高于 *（No.3）。
结合：f 先和 () 结合，说明 f 是一个函数。
修饰：函数的返回值类型是 int *。
结论：这是一个返回指针的函数。
int (*f)() —— 函数指针
分析：(*f) 有分组括号（No.1）。
结合：f 先和 * 结合，说明 f 是一个指针。
修饰：这个指针指向一个函数 int ... ()。
结论：这是一个指向函数的指针。


先用括号括起来的就是这个数据类型的本质.
(*)int->指针指向的类型是int

**** ()>[]>*
int (*arr[5])(int);本质是数组，arr[5]最先，*指针在后,（int）在最后后

函数指针数组，一个函数，返回的是全是指针的数组


在 int (*arr[5])(int); 这个定义中：
最后的 (int) 表示：这个指针所指向的目标（那个函数），必须接收一个 int 类型的参数。
最前面的 int 表示：这个指针所指向的目标（那个函数），执行完后会返回一个 int 类型的值。
2. 为什么说前面的指针数组会指向“函数”？
判定一个指针是不是“函数指针”，唯一的标志就是看它后面有没有跟圆括号 ()。
让我们通过对比来看看区别：
情况 A：指向变量的指针
code
C
int *p;
p 是指针。
p 后面没有括号。
所以它指向一个普通的 int 数据变量。
情况 B：指向函数的指针
code
C
int (*p)(int);
p 是指针（因为 *p 被括起来了）。
p 后面紧跟着一个 (int)。
关键规则：在 C 语言语法中，(*指针名)(参数列表) 这种结构是很多年约定俗成的铁律，专门用来表示“函数指针”。
编译器看到 (*p) 后面还有个括号，就会明白：“哦，这哥们指的地方不是存数据的，而是存代码（函数）的。”
3. 图解 int (*arr[5])(int) 的识别路径
让我们像编译器一样，从里向外扫描：
arr[5]：
先看到 arr 和 [5] 结合。
结论：这是一个数组，有 5 个格子。
*：
数组里的每个格子里装的是什么？前面有个 *。
结论：数组里装的全是指针。
(int)：
重点来了！这些指针指向什么？往后看，看到了 (int)。
判定：指针后面跟括号，说明指向的是函数（且该函数有一个 int 参数）。
最前面的 int：
这个函数的返回值是什么？
结论：返回 int。
完整翻译：
arr 是一个包含 5 个元素的数组，数组里存放的是指针，这些指针指向函数（参数是 int，返回是 int）。
4. 代码举例（这就清晰了）
光看定义很晕，看怎么用就懂了。
假设我们有两个简单的函数，它们的格式（参数和返回值）必须和定义的一模一样：
code
C
// 函数1：求平方
int square(int x) {
    return x * x;
}

// 函数2：求立方
int cube(int x) {
    return x * x * x;
}

int main() {
    // 定义这个函数指针数组
    // 意思是：arr 是一个数组，能存 2 个特定类型的“函数地址”
    int (*arr[2])(int); 

    // 把函数名（函数地址）存进去
    arr[0] = square; 
    arr[1] = cube;

    // 调用！
    // arr[0] 拿到的是 square 函数的地址
    // (10) 就是那个 (int) 参数
    int a = arr[0](10); // 等价于调用 square(10)，结果 100
    int b = arr[1](10); // 等价于调用 cube(10)，结果 1000
    
    return 0;
}
总结
那个 (int) 就像是插座的规格，规定了插在这个指针上的函数必须接受什么样的参数。
之所以指向函数，是因为指针变量后面紧挨着参数括号 ()，这是 C 语言识别函数的唯一特征。


就是说，没有必要专门定义一个指针指向函数返回的值，只能定义一个指向函数的指针
与 (*)int 类似，int (*)(int)就是一个指向后面东西的函数.

指针总是指向后面的运算!就是一个指针的指向或者类型总是后面进行的运算

int (*(*p)[5])(int);最内层:指针->指向*A[5](数组指针)->指向函数

综上所述，先看指针，后面的运算是指向的对象，最先计算的是本质，中文命名从内向外
*/

int a=20,b=a;
printf("%d %d",a,b);
    return 0;
}
/*

透过“发疯文学”疯狂的表象，我们看到的是精英学子在适应环境和应对与日俱增的压力过程中的阵痛甚至剧痛。这批热衷于“发疯”的青年人，往往拥有极高的成就动机以及“改变世界”的野心，但现实的反馈却充满了不确定性。
*/


/*
 {\huge \textbf{绩点压力下的失序与重组：\\ 从“发疯文学”看当代大学生情绪宣泄与心理重构} \par}
        \vspace{1em}
        
        % 作者
        {\large 丁杰瑞 $^{\dagger}$ \par}
        \vspace{0.5em}
        
        % 单位信息 (保留了范文的格式)
        {\small $^{\dagger}$(中国科学技术大学 少年班学院, 合肥 230026) \par}
        \vspace{1.5em}
        
        % 摘要
        \parbox{0.9\textwidth}{
            \textbf{摘\quad 要}\quad 本文以近期在高校网络社区中流行的“发疯文学”为切入点，结合《大学生心理健康》课程理论，探讨了这一现象在中国科学技术大学学生群体中兴起的心理动因。研究发现，“发疯文学”并非单纯的非理性宣泄，而是大学生在高压环境下的一种心理防御机制（退行）与情绪调节策略，反映了自我意识分化、社会比较焦虑以及认知评价偏差等多重心理困境。文章进一步运用教材中的CREAM学习法、SWOT分析及心理资本理论，提出了涵盖认知重构、学习策略优化及心理韧性培养的综合干预路径，旨在帮助大学生从被动的“发疯”转向主动的“掌控”，在优绩主义的浪潮中重建内心的秩序。
            
            \vspace{0.5em}
            \textbf{关键词}\quad 发疯文学，心理防御机制，CREAM学习法，心理资本，情绪韧性。

*/