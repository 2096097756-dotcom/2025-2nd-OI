#include <stdio.h>
#include <stdlib.h> // 用于 malloc, free
#include <string.h> // 用于 strcpy

int main() {
    // ==========================================
    // Part 1: 板书右上角的内容 (整数指针的基础用法)
    // ==========================================
    printf("=== Part 1: 整数指针示例 ===\n");
    
    int a;
    int *p = &a; // 指针 p 指向变量 a 的地址

    printf("请输入一个整数: ");
    // scanf 需要传入地址，p 本身就存了 a 的地址，所以不需要写 &p
    scanf("%d", p); 

    printf("你输入的整数是: %d\n\n", a);


    // ==========================================
    // Part 2: 板书中间的内容 (字符串拷贝陷阱与修正)
    // ==========================================
    printf("=== Part 2: 字符串拷贝修正 ===\n");

    char *s = "Hello"; // 源字符串

    /* 
       【错误写法原型】(板书上原本写的是 char *d;)
       char *d; 
       strcpy(d, s); 
       // 错误原因：d 是野指针，只定义了指针变量，没有分配存储数据的内存空间。
       // 运行会导致段错误 (Segmentation Fault)。
    */

    // ------------------------------------------
    // 【修正方案 A】板书上方黄字：静态数组法
    // ------------------------------------------
    {
        char d[100]; // 在【栈】上直接申请 100 字节的空间
        
        strcpy(d, s);
        printf("方案A (数组 d[100]): %s\n", d);
    }

    // ------------------------------------------
    // 【修正方案 B】板书中间插入的黄字：动态内存分配法
    // ------------------------------------------
    {
        char *d; // 定义指针
        
        // 在【堆】上申请内存 (对应板书: d = (char*)malloc...)
        // 这里申请 100 字节，或者根据 s 的长度申请: strlen(s) + 1
        d = (char *)malloc(100 * sizeof(char)); 

        if (d != NULL) { // 确保申请成功
            strcpy(d, s);
            printf("方案B (malloc):     %s\n", d);
            
            // 良好的习惯：堆内存用完要释放
            free(d); 
        }
    }

    return 0;
}