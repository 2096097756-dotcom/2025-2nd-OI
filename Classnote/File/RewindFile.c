#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 1. 定义结构体
struct student {
    char sNo[12];    // 学号
    char sName[20];  // 姓名
    int age;         // 年龄
    float scores[5]; // 5门课成绩
};

int main() {
    // 2. 初始化模拟数据
    struct student s2[3] = {
        {"202501", "Alice", 18, {85.5, 90.0, 88.0, 92.0, 80.0}},
        {"202502", "Bob",   19, {70.0, 75.5, 80.0, 65.0, 78.0}},
        {"202503", "Charlie",20,{95.0, 92.0, 98.0, 89.0, 90.0}}
    };

    FILE *fp;
    int i;

    // ==========================================
    // 第一步：打开文件 (注意这里改为 "w+")
    // ==========================================
    // "w+" 表示：以读/写方式打开。
    // 如果文件存在，内容会被清空；如果不存在，会建立新文件。
    if ((fp = fopen("data.txt", "w+")) == NULL) {
        puts("Open file error!");
        exit(-1);
    }
    
    /*
    fopen：打开文件函数。
    "data.txt"：文件名。如果文件不存在，会自动创建；如果文件已存在，会被清空/覆盖。
    "w" (Write)：表示以“只写”模式打开。
    NULL 检查：如果磁盘满了或者没有权限，文件打开会失败，fopen 返回 NULL。这一步是防错处理。
    */

    // ==========================================
    // 第二步：写入数据
    // ==========================================
    printf("Writing data to file...\n");
    for (i = 0; i < 3; i++) {
        fprintf(fp, "%s %s %d %.2f %.2f %.2f %.2f %.2f\n", 
                s2[i].sNo, s2[i].sName, s2[i].age,
                s2[i].scores[0], s2[i].scores[1], s2[i].scores[2], s2[i].scores[3], s2[i].scores[4]);
    }
    
    // 此时，文件指针(cursor)位于文件的最末尾。
    // 如果直接读，什么也读不到。

    // ==========================================
    // 第三步：使用 rewind() 倒带
    // ==========================================
    rewind(fp); 
    // 此时，文件指针重新回到了文件开头 (字节 0 的位置)
    printf("Data written. Rewind performed. Now reading...\n\n");


    // ==========================================
    // 第四步：直接读取数据 (不需要重新打开)
    // ==========================================
    struct student s5[3]; 

    for (i = 0; i < 3; i++) {
        fscanf(fp, "%s %s %d %f %f %f %f %f", 
               s5[i].sNo, s5[i].sName, &s5[i].age,
               &s5[i].scores[0], &s5[i].scores[1], &s5[i].scores[2], &s5[i].scores[3], &s5[i].scores[4]);
        
        // 打印验证
        printf("Student %d: %s, %s, Age: %d, Score1: %.2f\n", 
               i+1, s5[i].sNo, s5[i].sName, s5[i].age, s5[i].scores[0]);
    }

    // ==========================================
    // 第五步：最后统一关闭文件
    // ==========================================
    fclose(fp);
    printf("\nFile closed successfully.\n");

    return 0;
}

/*

这是一个非常好的问题！你的直觉在探索文件模式的边界，这对于理解文件操作非常重要。
直接回答你的问题：不行，会有严重的后果。
如果你把第二步读取时的 fopen 也改成了 "w+"，程序将无法读取到任何数据。
为什么不行？
关键在于 "w+"（和 "w"）的一个毁灭性特性：清空（Truncate）。
让我们推演一下如果不使用 rewind，而是两次都用 "w+" 会发生什么：
第一次打开 ("w+")：
系统创建一个新文件 data.txt（或者清空已存在的）。
程序写入 Alice, Bob, Charlie 的数据。
fclose 关闭文件。此时硬盘上的 data.txt 是完美的，里面有数据。
第二次打开 ("w+")：
灾难发生在这里！
当 fopen("data.txt", "w+") 执行的那一瞬间，它的规则是：“打开文件用于读写，如果在文件存在，将其长度截断为 0（即清空内容）”。
刚才辛苦写入的 Alice, Bob, Charlie 瞬间全部消失。
文件变成了一张白纸。
后续读取：
程序尝试 fscanf。
因为文件是空的，fscanf 读不到任何东西，直接返回错误（EOF）。
你的屏幕上会打印出乱码（因为 s5 数组里是随机垃圾值），或者全 0。

正确的模式搭配
如果你坚持不使用 rewind，而是采用“关闭再打开”的策略，你的模式选择必须遵循以下逻辑：
步骤	fopen 模式	解释	结果
第一次 (写)	"w" 或 "w+"	只要带 w，就会创建新文件或清空旧文件。	可行 (我们需要写数据)
中间	fclose	保存数据到硬盘。	数据安全落地
第二次 (读)	只能是 "r" 或 "r+"	r 表示只读，r+ 表示读写。重点是它们都不会清空文件。	可行
第二次 (读)	"w" 或 "w+"	绝对禁止。带 w 会再次清空文件。	数据丢失

总结
"w" / "w+"：霸道模式。不管文件里有什么，打开就是一个新开始（清空）。适合第一次写入。
"r" / "r+"：温柔模式。打开文件时保留原有内容。适合后续读取。
所以，原来的代码写法（第一次用 "w"，第二次用 "r"）是完全正确的标准写法。如果你想统一模式，只有配合 rewind() 并在一次打开中完成操作，才能一直使用 "w+"。



*/


/*

这是一个非常敏锐的尝试！
答案是：不行（或者说极其危险）。
虽然 "r+" 看起来很美好（既能读又能写，还不会像 "w+" 那样无脑清空），但如果把你代码里的两次 fopen 都改成 "r+"，会遇到两个致命问题：
致命问题 1：第一步就会报错（如果文件不存在）
"w" 和 "w+" 的特权：如果文件 data.txt 不存在，它们会自动帮你创建一个。
"r+" 的限制：它非常娇气。它要求文件必须已经存在。
如果这是你第一次运行程序（或者你刚刚删除了 data.txt），fopen("data.txt", "r+") 会直接失败，返回 NULL。
你的代码中有 if (fp == NULL) exit(-1);，所以程序会直接闪退。
致命问题 2：残留数据的“幽灵”（如果文件已存在）
假设文件已经存在，程序没有报错。"r+" 不会清空文件，而是从头开始覆盖。这听起来没问题？请看下面的演示：
场景假设：
上次运行程序，你写入了比较长的数据（比如名字很长）：
Student: Christopher (共 20 个字符)
这次运行程序，你写入了比较短的数据：
Student: Bob (共 12 个字符)
如果是 "w" 模式（正确做法）：
它会先把旧文件删光，变成一张白纸，然后写入。
结果：Student: Bob (干净！)
如果是 "r+" 模式（错误做法）：
它不删文件，直接从第一个字节开始覆盖。
Student: Bob 覆盖了 Student: Chr
但是后面的 istopher 没有被覆盖，依然留在文件里！
结果文件内容会变成：
Student: Bobistopher
这就导致了数据损坏（Data Corruption）。读取的时候，格式全乱了，程序可能会解析出错误的数值或者乱码。
总结：C 语言文件模式速查表
为了彻底搞清楚，看这个对比就懂了：


模式	如果文件不存在	如果文件存在	以前的内容去哪了？	用途
"w"	自动创建	打开	全部清空 (截断为0)	我要写新数据 (最常用)
"r"	报错 (NULL)	打开	还在	我要读数据 (最常用)
"w+"	自动创建	打开	全部清空 (截断为0)	我要写新数据，写完马上回头读它
"r+"	报错 (NULL)	打开	还在 (只能覆盖)	我要修改文件中间的某几个字
"a"	自动创建	打开	还在 (只能追加到末尾)	我要写日志 (Log)

结论
在你的这个练习代码中：
第一步（写入）：必须用 "w" (或者 "w+")。
你需要确保文件被创建。
你需要确保旧的垃圾数据被清空。
第二步（读取）：可以用 "r" (或者 "r+")。
因为此时文件肯定存在了（第一步刚写完）。
因为只是读取，不涉及修改，用哪个都行，但 "r" 最标准。
所以，不要把第一次打开改成 "r+"，否则只要文件不存在，你的程序就跑不起来。
*/

/*

如果不加 fclose，后果取决于你是在代码的哪个位置漏掉了它。在你的这份代码中，漏掉 fclose 会导致从**“数据丢失”到“程序逻辑完全崩坏”**等一系列严重问题。


数据还没写入硬盘（数据丢失）：
C 语言的文件写入是**“带缓冲”的。你调用 fprintf 时，数据实际上是暂时存在了内存里的一个缓冲区（Buffer）**，并没有立刻写到硬盘上的 data.txt 里。
只有调用 fclose（或者 fflush）时，系统才会把缓冲区的内容“冲刷”到硬盘。
结果：硬盘上的文件可能是空的，或者是残缺的。
指针丢失（内存泄漏）：
fp 变量原本指向第一次打开的文件。当你执行 fp = fopen(..., "r") 时，fp 被赋值为新的地址。
第一次打开的那个文件连接（Handle）就“断了线”，你再也找不到它，也关不掉它了。它会一直占用系统资源直到程序结束。
打开失败（文件被锁定）：
在 Windows 上：如果一个文件正被以“写模式”打开且没关闭，操作系统通常禁止其他进程（甚至本进程的第二次尝试）再次打开它。
结果：第二个 fopen 会返回 NULL，你的程序会打印 "Open file error (read)!" 然后退出。
*/